// RaeenOS Kernel
// --------------

#include "idt.h"
#include "pmm.h"
#include "include/multiboot.h"
#include "include/driver.h"
#include "drivers/pci/pci_driver.h"

#include "string.h"
#include "syscall.h"
#include "timer.h"
#include "keyboard.h"
#include "graphics.h"
#include "mouse.h"
#include "window.h"
#include "ui/widget.h"
#include "fs/vfs.h"
#include "ui/terminal.h"
#include "ipc/pipe.h"
#include "process/process.h"
#include "exec.h"
#include <stdint.h>

// A simple click handler for our test button
// A simple, hand-crafted userland program and its header.
// In a real system, this would be generated by a compiler and linker.
#define SHELL_CODE_VADDR 0x08048000
#define SHELL_DATA_VADDR 0x08049000

const char shell_data[] = "Hello from a loaded program!\n";

// mov eax, 4 (SYS_WRITE); mov ebx, 1 (stdout); mov ecx, data_addr; mov edx, data_len; int 0x80; jmp $
unsigned char shell_code[] = {
    0xb8, 0x04, 0x00, 0x00, 0x00,       // mov eax, 4 (SYS_WRITE)
    0xbb, 0x01, 0x00, 0x00, 0x00,       // mov ebx, 1 (stdout)
    0xb9, 0x00, 0x90, 0x04, 0x08,       // mov ecx, SHELL_DATA_VADDR
    0xba, sizeof(shell_data), 0, 0, 0,  // mov edx, sizeof(shell_data)
    0xcd, 0x80,                         // int 0x80
    0xeb, 0xfe                          // jmp $
};

extern process_t* exec_load(const char* path, int argc, char** argv);

void test_button_on_click(widget_t* widget, int x, int y) {
    // This is a simple example. In a real UI, we'd need a more robust way
    // to manage string memory.
    static int click_count = 0;
    click_count++;

    // Using memcpy to update the text buffer allocated for the widget
    if (click_count % 2 == 1) {
        memcpy(widget->text, "Clicked!", 9); // "Clicked!" + null terminator
    } else {
        memcpy(widget->text, "Click Me!", 10); // "Click Me!" + null terminator
    }
}



void kernel_early_init(uint32_t magic, uint32_t mboot_ptr) {
    idt_init();

    multiboot_info_t* mboot_info = (multiboot_info_t*)mboot_ptr;

    // Check if Multiboot magic is valid and memory map is available
    if (magic != MULTIBOOT_BOOTLOADER_MAGIC || !(mboot_info->flags & MULTIBOOT_MEMORY_INFO)) {
        // Handle error: Bootloader did not provide valid Multiboot info
        // For now, we'll just halt.
        vga_puts("Error: Invalid Multiboot info or no memory map provided!\n");
        asm volatile ("cli; hlt");
    }

    pmm_init_from_mmap(mboot_info->mmap_addr, mboot_info->mmap_length);
    paging_init();
    memory_init(); // Initialize kernel heap
    swap_init(); // Initialize swap mechanism
}

void kernel_late_init(void) {
    ata_init(); // Initialize ATA driver
    theme_init(); // Initialize theming engine
    syscall_init();
    vfs_init(); // Initialize VFS before mounting filesystems

    // Mount FAT32 as root filesystem
    vfs_root = fat32_mount((uint8_t*)ATA_MASTER); // Assuming master drive for now
    if (vfs_root) {
        vga_puts("FAT32 filesystem mounted as root.\n");
    } else {
        vga_puts("Failed to mount FAT32 filesystem!\n");
    }

    pci_driver_init(); // Initialize PCI bus driver
    pci_enumerate_devices(); // Enumerate PCI devices and initialize their drivers

    timer_init(100); // 100 Hz
    keyboard_init();
    graphics_init(mboot_info);
    mouse_init();
    event_queue_init();
    process_init();
}

    // VFS Test
    vfs_node_t* dev_dir = vfs_create(vfs_root, "dev", VFS_DIRECTORY);
    if (dev_dir) {
        vfs_node_t* null_file = vfs_create(dev_dir, "null", VFS_FILE);
        if (null_file) {
            char* test_data = "test";
            vfs_write(null_file, 0, 5, (uint8_t*)test_data);

            char read_buffer[5] = {0};
            vfs_read(null_file, 0, 5, (uint8_t*)read_buffer);
            // In a real scenario, we'd assert(strcmp(test_data, read_buffer) == 0)
            // For now, this serves as a silent integration test.
        }
    }

    // Create a mock executable in the VFS
    vfs_node_t* bin_dir = vfs_create(vfs_root, "bin", VFS_DIRECTORY);
    if (bin_dir) {
        vfs_node_t* shell_file = vfs_create(bin_dir, "shell", VFS_FILE);
        if (shell_file) {
            // Construct the executable file in a temporary buffer
            uint32_t header_size = sizeof(raeexec_header_t);
            uint32_t pheaders_size = sizeof(raeexec_pheader_t) * 2;
            uint32_t code_size = sizeof(shell_code);
            uint32_t data_size = sizeof(shell_data);
            uint32_t total_size = header_size + pheaders_size + code_size + data_size;

            uint8_t* exec_buffer = (uint8_t*)pmm_alloc_frame();

            // Header
            raeexec_header_t* header = (raeexec_header_t*)exec_buffer;
            header->magic = RAEEXEC_MAGIC;
            header->entry = SHELL_CODE_VADDR;
            header->ph_offset = header_size;
            header->ph_entry_size = sizeof(raeexec_pheader_t);
            header->ph_num = 2;

            // Program Headers
            raeexec_pheader_t* pheader_code = (raeexec_pheader_t*)(exec_buffer + header_size);
            raeexec_pheader_t* pheader_data = (raeexec_pheader_t*)(exec_buffer + header_size + sizeof(raeexec_pheader_t));

            // Code segment (.text)
            pheader_code->type = PT_LOAD;
            pheader_code->offset = header_size + pheaders_size;
            pheader_code->vaddr = SHELL_CODE_VADDR;
            pheader_code->file_size = code_size;
            pheader_code->mem_size = code_size;
            pheader_code->flags = PF_R | PF_X;

            // Data segment (.data)
            pheader_data->type = PT_LOAD;
            pheader_data->offset = header_size + pheaders_size + code_size;
            pheader_data->vaddr = SHELL_DATA_VADDR;
            pheader_data->file_size = data_size;
            pheader_data->mem_size = data_size;
            pheader_data->flags = PF_R | PF_W;

            // Copy code and data into the buffer
            memcpy(exec_buffer + header_size + pheaders_size, shell_code, code_size);
            memcpy(exec_buffer + header_size + pheaders_size + code_size, shell_data, data_size);

            // Write buffer to VFS file
            vfs_write(shell_file, 0, total_size, exec_buffer);
            
            pmm_free_frame(exec_buffer);
        }
    }

    // Launch the userland shell from the VFS
    process_t* shell_proc = exec_load("/bin/shell", 0, NULL);

    // Manually set up stdin/stdout/stderr for the new process
    if (shell_proc) {
        vfs_node_t* tty_in = vfs_find("/dev/tty_in");
        vfs_node_t* tty_out = vfs_find("/dev/tty_out");
        if (tty_in && tty_out) {
            shell_proc->fd_table[0] = tty_in;
            shell_proc->fd_table[1] = tty_out;
            shell_proc->fd_table[2] = tty_out;
        }
    }

    // Create a couple of windows with titles
    window_create(50, 50, 500, 400);
    window_t* main_window = window_create(150, 150, 400, 300);

    // Create a button widget with a text label in the second window
    if (main_window) {
        widget_t* button = widget_create(main_window, WIDGET_TYPE_BUTTON, 20, 40, 100, 30, "Click Me!");
        if (button) {
            button->on_click = test_button_on_click;
        }
    }

    // Create a terminal window
    widget_t* term_widget = NULL;
    window_t* term_window = window_create(200, 250, 640, 480);
    if (term_window) {
        // The terminal widget fills the window's content area
        term_widget = terminal_create(term_window, 0, 0, term_window->width, term_window->height - 20);

        // Expose the terminal's pipes in the VFS
        if (term_widget) {
            vfs_node_t* dev_dir = vfs_find("/dev");
            if (!dev_dir) {
                dev_dir = vfs_create(vfs_root, "dev", VFS_DIRECTORY);
            }

            if (dev_dir) {
                // Create VFS nodes for the pipes
                vfs_node_t* tty_in_node = ramfs_create_pipe(dev_dir, "tty_in");
                vfs_node_t* tty_out_node = ramfs_create_pipe(dev_dir, "tty_out");

                // Link them to the terminal's actual pipes
                if (tty_in_node) {
                    pipe_destroy(tty_in_node->pipe); // Free the default pipe
                    tty_in_node->pipe = terminal_get_input_pipe(term_widget);
                }
                if (tty_out_node) {
                    pipe_destroy(tty_out_node->pipe); // Free the default pipe
                    tty_out_node->pipe = terminal_get_output_pipe(term_widget);
                }
            }
        }
    }

    // Enable interrupts
    asm volatile ("sti");

    // Main event loop for UI interaction
    struct mouse_state_t current_mouse;
    window_t* dragged_window = NULL;
    int drag_offset_x = 0;
    int drag_offset_y = 0;
    uint8_t last_left_button_state = 0;

    while (1) {
        mouse_get_state(&current_mouse);

        // Check for drag start or widget click
        if (current_mouse.left_button && !last_left_button_state) {
            window_t* target = window_find_at_coords(current_mouse.x, current_mouse.y);
            
            if (target) {
                 // Check if the click was on the title bar (first 20 pixels)
                if ((current_mouse.y - target->y) < 20) {
                    dragged_window = target;
                    drag_offset_x = current_mouse.x - target->x;
                    drag_offset_y = current_mouse.y - target->y;
                } else {
                    // Click was inside the window content area, check for widgets
                    int local_x = current_mouse.x - target->x;
                    int local_y = current_mouse.y - target->y;
                    widget_t* clicked_widget = widget_find_at_coords(target, local_x, local_y);
                    if (clicked_widget && clicked_widget->on_click) {
                        clicked_widget->on_click(clicked_widget, local_x, local_y);
                    }
                }
            }
        }

        // Check for drag end
        if (!current_mouse.left_button && last_left_button_state) {
            dragged_window = NULL;
        }

        // Handle window dragging
        if (dragged_window) {
            dragged_window->x = current_mouse.x - drag_offset_x;
            dragged_window->y = current_mouse.y - drag_offset_y;
        }

        last_left_button_state = current_mouse.left_button;

        // Handle keyboard input
        char key_char;
        if (keyboard_read(&key_char, 1) > 0 && term_widget) {
            terminal_handle_keypress(term_widget, key_char);
        }

        // Process terminal input pipe
        if (term_widget) {
            terminal_process_input(term_widget);
        }

        // Redraw the entire screen
        window_manager_compose();
    }
}
